<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CommodityTracking: ct Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CommodityTracking
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ct Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classct_1_1_frame_history.html">FrameHistory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classct_1_1_skeleton.html">Skeleton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classct_1_1_skeleton_tracker.html">SkeletonTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4e96dbe86f903970e680ecca7ea4d1ed"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacect.html#a4e96dbe86f903970e680ecca7ea4d1ed">extractUserMask</a> (cv::Mat &amp;delta, double sensitivity)</td></tr>
<tr class="separator:a4e96dbe86f903970e680ecca7ea4d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec15a370267aee5f2c4a53a90415f96"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacect.html#a9ec15a370267aee5f2c4a53a90415f96">simplifyUserMask</a> (cv::Mat &amp;mask, cv::Mat &amp;frame, int minimumArclength)</td></tr>
<tr class="separator:a9ec15a370267aee5f2c4a53a90415f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93704c6d49e76e2cc3604636c0ac05e"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacect.html#ac93704c6d49e76e2cc3604636c0ac05e">highUserMask</a> (cv::Mat &amp;delta, cv::Mat &amp;frame, int minimumArclength, double sensitivity)</td></tr>
<tr class="separator:ac93704c6d49e76e2cc3604636c0ac05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5775e19f3d899f271bf4ba3732d0a528"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacect.html#a5775e19f3d899f271bf4ba3732d0a528">getEdgePoints</a> (cv::Mat frame, cv::Mat simplifiedUserMask, int minimumArclength, bool draw, std::vector&lt; std::vector&lt; cv::Point &gt; &gt; &amp;edgePointsList)</td></tr>
<tr class="separator:a5775e19f3d899f271bf4ba3732d0a528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1f04fe68910990ee9c4483a048011e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacect.html#abb1f04fe68910990ee9c4483a048011e">skeletonFromEdgePoints</a> (std::vector&lt; <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> * &gt; history, std::vector&lt; cv::Point &gt; &amp;centers, std::vector&lt; std::vector&lt; cv::Point &gt; &gt; &amp;edgePointsList, int width, int height)</td></tr>
<tr class="separator:abb1f04fe68910990ee9c4483a048011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9afa041c4b84691258be719e7d9cd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacect.html#adc9afa041c4b84691258be719e7d9cd4">autoCalibrateSensitivity</a> (int initialUserSensitivity, cv::VideoCapture &amp;stream, int minimumArclength, int interval)</td></tr>
<tr class="separator:adc9afa041c4b84691258be719e7d9cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8756e0d83d9f7bc2713ba079338324"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacect.html#abb8756e0d83d9f7bc2713ba079338324">getSkeleton</a> (std::vector&lt; <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> * &gt; oldSkeletons, cv::VideoCapture &amp;stream, <a class="el" href="classct_1_1_frame_history.html">FrameHistory</a> &amp;history, int userSensitivity, int minimumArclength, double scaleFactor, bool shouldFlip)</td></tr>
<tr class="separator:abb8756e0d83d9f7bc2713ba079338324"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for CommodityTracking functions </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adc9afa041c4b84691258be719e7d9cd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ct::autoCalibrateSensitivity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initialUserSensitivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::VideoCapture &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimumArclength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>autoCalibrateSensitivty determines the optimal sensitivity level for extractUserMask. initialUserSensitivity is a pointer to the initial sensitivity for calibration. autoCalibrateSensitivity runs a small portion of the algorithm many times to find the minimum sensitivity. It assumes that there is no motion to start with to find the setting that yields a blank user mask. In other words, you must instruct users to completely exit the camera frame before and during this function call. Else, the algorithm will think that the user itself is noise! interval is the amount to increase the sensitivity each iteration. minimumArclength should be equal to the value actually used for getSkeleton. autoCalibrateSensitivity will return the optimal sensitivity </p>

</div>
</div>
<a class="anchor" id="a4e96dbe86f903970e680ecca7ea4d1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ct::extractUserMask </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sensitivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>extractUserMask computes a mask of the user given a generic motion mask. Delta is a motion mask, as returned by <a class="el" href="classct_1_1_frame_history.html#a675b6ba79917f82cd2b49ad57bc5dd5c">FrameHistory::motion</a> . Sensitivity is a rather arbitrary setting of how sensitive thresholding should be. Sensitivity should be calibrated by autoCalibrateSensitivity in most cases. extractUserMask returns a black-and-white mask of the user; ideally, performing a bitwise_and on the output of this function and the original frame will produce a perfect image of the user itself. It is often desirable to smooth this output through simplifyUserMask, but simplifyUserMask is much more expensive in terms of CPU then extractUserMask. </p>

</div>
</div>
<a class="anchor" id="a5775e19f3d899f271bf4ba3732d0a528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; cv::Point &gt; ct::getEdgePoints </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>simplifiedUserMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimumArclength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; cv::Point &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgePointsList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>getEdgePoints returns a list of "interesting" points from a user mask. It returns center points (later fed to <a class="el" href="classct_1_1_skeleton.html#a52747c7f11c96f71e06165dfe2dccc9e">Skeleton::center</a> ), and returns edge points by reference as the last parameter. See the source of getSkeleton for usage. </p>

</div>
</div>
<a class="anchor" id="abb8756e0d83d9f7bc2713ba079338324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> * &gt; ct::getSkeleton </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> * &gt;&#160;</td>
          <td class="paramname"><em>oldSkeletons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::VideoCapture &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classct_1_1_frame_history.html">FrameHistory</a> &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>userSensitivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimumArclength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaleFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldFlip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>getSkeleton exposes a high-level API for performing skeleton tracking. In most applications, you should use getSkeleton and autoCalibrateSensitivity exclusively and ignore the lower level parts of the algorithm exposed. getSkeleton takes in a stream (from OpenCV), a <a class="el" href="classct_1_1_frame_history.html">FrameHistory</a> object, calibrated userSensitivity (see autoCalibrateSensitivity) and a few settings for tweaking performance and accuracy. scaleFactor is some fractional factor that is used to scale each frame, the idea is to minimize the amount of work required to perform tracking at the expense of accuracy. </p>

</div>
</div>
<a class="anchor" id="ac93704c6d49e76e2cc3604636c0ac05e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ct::highUserMask </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimumArclength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sensitivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>highUserMask implements watershed segmentation it internally leverages simplifyUserMask and extractUserMaskfor its input, and manages all of the pre/post processing needed for watershed itself highUserMask provides a very high-level, one-size-fits-all solution for user mask extraction, and is therefore used by CommodityTracking itself. additionally, it is useful for general motion-based segmentation algorithms. In general, highUserMask should be called for manual user detection, if skeleton tracking is not desired. </p>

</div>
</div>
<a class="anchor" id="a9ec15a370267aee5f2c4a53a90415f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ct::simplifyUserMask </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimumArclength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>simplifyUserMask takes in a mask from extractUserMask and simplifies it to improve accuracy at the cost of CPU time. It performs an intelligent algorithm for finding user contours, but still requires a call to extractUserMask as its input for mask. frame is the original frame from the camera, and minimumArclength is a threshold used for discarding distant or small user-like objects. An appropiate value is 150, but you may need to experiment. </p>

</div>
</div>
<a class="anchor" id="abb1f04fe68910990ee9c4483a048011e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> * &gt; ct::skeletonFromEdgePoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> * &gt;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; cv::Point &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgePointsList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>skeletonFromEdgePoints analyzes the output of getEdgePoints to generate a <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> object. Points are classified based on position relative the <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> center. <a class="el" href="classct_1_1_skeleton.html">Skeleton</a> objects are constructed from skeletonFromEdgePoints. More than one user can theoretically be detected, but in practice only one user works well. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 28 2015 11:59:38 for CommodityTracking by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
